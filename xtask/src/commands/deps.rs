use anyhow::Result;
use chrono::Local;
use regex::Regex;
use std::collections::HashMap;
use xshell::{cmd, Shell};

use crate::utils::find_workspace_root;

pub fn update_deps(sh: &Shell, create_pr: bool) -> Result<()> {
    println!("Updating submodules to match Crashpad's DEPS...");

    let workspace_root = find_workspace_root(sh)?;
    sh.change_dir(&workspace_root);

    // Step 1: Update crashpad to latest main
    println!("ðŸ“¦ Updating Crashpad to latest main...");
    sh.change_dir(&workspace_root);
    cmd!(
        sh,
        "git submodule update --init --remote crashpad-sys/third_party/crashpad"
    )
    .run()?;
    sh.change_dir(workspace_root.join("crashpad-sys/third_party/crashpad"));
    let crashpad_rev = cmd!(sh, "git rev-parse HEAD").read()?;
    println!("  Crashpad updated to: {}", crashpad_rev.trim());

    // Step 2: Parse DEPS file
    println!("ðŸ“„ Parsing DEPS file...");
    let deps_path = workspace_root.join("crashpad-sys/third_party/crashpad/DEPS");
    let deps_content = sh.read_file(&deps_path)?;
    let deps = parse_deps(&deps_content)?;

    // Step 3: Skip .gitmodules update (no longer needed)
    // Submodules are tracked by their commit hash, not branch
    sh.change_dir(&workspace_root);

    // Step 4: Update each submodule to the specified revision
    println!("ðŸ”„ Updating submodules to specified revisions...");
    sh.change_dir(&workspace_root);
    for (name, rev) in &deps {
        if name == "crashpad" {
            continue; // Already updated
        }
        let submodule_path = format!("crashpad-sys/third_party/{name}");
        if workspace_root.join(&submodule_path).exists() {
            println!("  Updating {name} to {rev}");
            // First fetch the latest refs
            cmd!(sh, "git submodule update --init {submodule_path}").run()?;
            // Then checkout specific revision in submodule
            sh.change_dir(workspace_root.join(&submodule_path));
            cmd!(sh, "git fetch origin").run()?;
            cmd!(sh, "git checkout {rev}").run()?;
            sh.change_dir(&workspace_root);
            // Record the change in the parent repository
            cmd!(sh, "git add {submodule_path}").run()?;
        }
    }

    sh.change_dir(&workspace_root);

    // Step 5: Check for changes
    let status = cmd!(sh, "git status --porcelain").read()?;
    if status.is_empty() {
        println!("âœ… No changes needed, already up to date!");
        return Ok(());
    }

    // Step 6: Show summary of changes
    println!("\nðŸ“‹ Summary of changes:");
    cmd!(sh, "git diff --stat").run()?;

    if create_pr {
        // Step 7: Create branch and commit
        let date = Local::now().format("%Y%m%d").to_string();
        let branch_name = format!("auto/update-deps-{date}");

        println!("\nðŸŒ¿ Creating branch: {branch_name}");
        cmd!(sh, "git checkout -b {branch_name}").run()?;

        println!("ðŸ’¾ Committing changes...");
        cmd!(sh, "git add -A").run()?;
        let commit_msg = format!("chore: update submodules to match Crashpad DEPS\n\nAutomatically updated submodules to match revisions in:\ncrashpad-sys/third_party/crashpad/DEPS @ {}", crashpad_rev.trim());
        cmd!(sh, "git commit -m {commit_msg}").run()?;

        println!("ðŸ“¤ Pushing branch...");
        cmd!(sh, "git push -u origin {branch_name}").run()?;

        println!("ðŸ”„ Creating pull request...");
        let pr_body = "This PR automatically updates submodules to match the revisions specified in Crashpad's DEPS file.\n\nGenerated by `cargo xtask update-deps --create-pr`";

        // Explicitly pass GITHUB_TOKEN to gh command for GitHub Actions compatibility
        let gh_cmd = cmd!(sh, "gh pr create --title 'chore: update submodules to match Crashpad DEPS' --body {pr_body}");
        let gh_cmd = if let Ok(token) = std::env::var("GITHUB_TOKEN") {
            gh_cmd.env("GITHUB_TOKEN", token)
        } else {
            // Fallback for local development where gh might be authenticated differently
            gh_cmd
        };
        gh_cmd.run()?;

        println!("âœ… Pull request created successfully!");
    } else {
        println!("\nðŸ’¡ To create a PR, run: cargo xtask update-deps --create-pr");
    }

    Ok(())
}

fn parse_deps(content: &str) -> Result<HashMap<String, String>> {
    let mut deps = HashMap::new();

    // Pattern to match dependencies in DEPS file
    // Format: 'crashpad/third_party/xxx/xxx': ... '@' + 'hash',
    let dep_pattern =
        Regex::new(r"'crashpad/third_party/([^/]+)/[^']+':.*?@'\s*\+\s*\n\s*'([a-f0-9]{40})'")?;

    for cap in dep_pattern.captures_iter(content) {
        let name = cap.get(1).unwrap().as_str();
        let rev = cap.get(2).unwrap().as_str();
        deps.insert(name.to_string(), rev.to_string());
    }

    // Add crashpad itself (current HEAD)
    deps.insert("crashpad".to_string(), "HEAD".to_string());

    Ok(deps)
}
