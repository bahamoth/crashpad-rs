name: Test Report

on:
  workflow_run:
    workflows: ["Build Android", "Build iOS", "Build macOS", "Build Linux"]
    types:
      - completed

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  report:
    if: github.event.workflow_run.event == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Download workflow artifacts
        uses: actions/github-script@v7
        id: download
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.payload.workflow_run.id,
            });
            console.log('Found artifacts:', artifacts.data.total_count);
            
            // Download test result artifacts
            const fs = require('fs');
            for (const artifact of artifacts.data.artifacts) {
              if (artifact.name.startsWith('test-results-')) {
                console.log(`Downloading artifact: ${artifact.name}`);
                const download = await github.rest.actions.downloadArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id,
                  archive_format: 'zip',
                });
                fs.writeFileSync(`${artifact.name}.zip`, Buffer.from(download.data));
              }
            }
      
      - name: Extract and Parse Test Results
        id: parse
        run: |
          # Extract all test result artifacts
          mkdir -p test-results
          for zip in test-results-*.zip; do
            if [ -f "$zip" ]; then
              unzip -o "$zip" -d test-results/ || true
            fi
          done
          
          # Parse test results and create summary
          if ls test-results/*.txt 1> /dev/null 2>&1; then
            echo "Found test result files:"
            ls -la test-results/*.txt
            
            # Initialize counters
            TOTAL_PASS=0
            TOTAL_FAIL=0
            TOTAL_SKIP=0
            TOTAL_COUNT=0
            PLATFORMS=""
            
            for file in test-results/*.txt; do
              if [ -f "$file" ]; then
                PLATFORM=$(grep "^platform:" "$file" | cut -d' ' -f2)
                PLATFORMS="${PLATFORMS}${PLATFORM} "
                
                # Extract test counts from new unified format
                PASSED=$(grep "^test_passed:" "$file" | cut -d' ' -f2 || echo "0")
                FAILED=$(grep "^test_failed:" "$file" | cut -d' ' -f2 || echo "0")
                SKIPPED=$(grep "^test_skipped:" "$file" | cut -d' ' -f2 || echo "0")
                COUNT=$(grep "^test_count:" "$file" | cut -d' ' -f2 || echo "0")
                
                # Add to totals
                TOTAL_PASS=$((TOTAL_PASS + PASSED))
                TOTAL_FAIL=$((TOTAL_FAIL + FAILED))
                TOTAL_SKIP=$((TOTAL_SKIP + SKIPPED))
                TOTAL_COUNT=$((TOTAL_COUNT + COUNT))
                
                echo "Platform: $PLATFORM - Tests: $COUNT, Passed: $PASSED, Failed: $FAILED, Skipped: $SKIPPED"
              fi
            done
            
            echo "total_pass=$TOTAL_PASS" >> $GITHUB_OUTPUT
            echo "total_fail=$TOTAL_FAIL" >> $GITHUB_OUTPUT
            echo "total_skip=$TOTAL_SKIP" >> $GITHUB_OUTPUT
            echo "total_count=$TOTAL_COUNT" >> $GITHUB_OUTPUT
            echo "platforms=$PLATFORMS" >> $GITHUB_OUTPUT
          else
            echo "No test results found"
            echo "total_pass=0" >> $GITHUB_OUTPUT
            echo "total_fail=0" >> $GITHUB_OUTPUT
            echo "total_skip=0" >> $GITHUB_OUTPUT
            echo "total_count=0" >> $GITHUB_OUTPUT
            echo "platforms=none" >> $GITHUB_OUTPUT
          fi
      
      - name: Generate PR Comment
        uses: actions/github-script@v7
        with:
          script: |
            const workflow = context.payload.workflow_run;
            const pr = workflow.pull_requests[0];
            
            if (!pr) {
              console.log('No PR associated with this workflow run');
              return;
            }
            
            const totalPass = parseInt('${{ steps.parse.outputs.total_pass }}') || 0;
            const totalFail = parseInt('${{ steps.parse.outputs.total_fail }}') || 0;
            const totalSkip = parseInt('${{ steps.parse.outputs.total_skip }}') || 0;
            const totalCount = parseInt('${{ steps.parse.outputs.total_count }}') || 0;
            const platforms = '${{ steps.parse.outputs.platforms }}' || 'none';
            
            const emoji = workflow.conclusion === 'success' ? '‚úÖ' : '‚ùå';
            const status = workflow.conclusion === 'success' ? 'Passed' : 'Failed';
            
            let body = `## üìä Crashpad Test Results\n\n`;
            
            // Overall summary
            body += `### Summary\n`;
            body += `| Workflow | Status | Tests | Passed | Failed | Skipped | Duration |\n`;
            body += `|----------|--------|-------|--------|--------|---------|----------|\n`;
            body += `| ${workflow.name} | ${emoji} ${status} | ${totalCount} | ‚úÖ ${totalPass} | ‚ùå ${totalFail} | ‚è≠Ô∏è ${totalSkip} | ${Math.round((new Date(workflow.updated_at) - new Date(workflow.created_at)) / 1000)}s |\n`;
            body += `\n`;
            
            // Detailed results per platform if test results were found
            if (totalCount > 0) {
              body += `### Detailed Results\n\n`;
              
              // Read and display test results from artifacts
              const fs = require('fs');
              const testFiles = fs.readdirSync('test-results').filter(f => f.endsWith('.txt'));
              
              for (const file of testFiles) {
                const content = fs.readFileSync(`test-results/${file}`, 'utf8');
                const lines = content.split('\n').filter(l => l.trim());
                
                // Parse key-value pairs
                const data = {};
                lines.forEach(line => {
                  if (line.includes(':')) {
                    const [key, ...valueParts] = line.split(':');
                    data[key.trim()] = valueParts.join(':').trim();
                  }
                });
                
                const platform = data.platform || 'Unknown';
                const arch = data.arch || '';
                const testCount = data.test_count || '0';
                const testPassed = data.test_passed || '0';
                const testFailed = data.test_failed || '0';
                const testSkipped = data.test_skipped || '0';
                const duration = data.total_duration || 'N/A';
                
                // Platform emoji
                const platformEmoji = platform === 'Android' ? 'ü§ñ' : 
                                     platform === 'iOS' ? 'üçé' : 
                                     platform === 'macOS' ? 'üñ•Ô∏è' : 
                                     platform === 'Linux' ? 'üêß' : 'üíª';
                
                body += `#### ${platformEmoji} ${platform}${arch ? ` (${arch})` : ''}\n`;
                body += `- **Tests:** ${testCount} total\n`;
                body += `- **Results:** ‚úÖ ${testPassed} passed, ‚ùå ${testFailed} failed, ‚è≠Ô∏è ${testSkipped} skipped\n`;
                body += `- **Duration:** ${duration}\n`;
                
                // Show slowest tests for Linux/macOS
                if ((platform === 'Linux' || platform === 'macOS') && lines.some(l => l.includes('slowest_tests'))) {
                  body += `\n<details><summary>‚è±Ô∏è Slowest Tests</summary>\n\n`;
                  let inSlowest = false;
                  lines.forEach(line => {
                    if (line.includes('slowest_tests:')) {
                      inSlowest = true;
                    } else if (inSlowest && line.startsWith('  - ')) {
                      body += `${line}\n`;
                    } else if (inSlowest && !line.startsWith('  ')) {
                      inSlowest = false;
                    }
                  });
                  body += `\n</details>\n`;
                }
                
                // Show failed tests if any
                if (parseInt(testFailed) > 0 && lines.some(l => l.includes('failed_tests'))) {
                  body += `\n<details><summary>‚ùå Failed Tests</summary>\n\n`;
                  let inFailed = false;
                  lines.forEach(line => {
                    if (line.includes('failed_tests:')) {
                      inFailed = true;
                    } else if (inFailed && line.startsWith('  - ')) {
                      body += `${line}\n`;
                    }
                  });
                  body += `\n</details>\n`;
                }
                
                body += `\n`;
              }
            } else {
              // Fallback to simple platform detection
              if (workflow.name.includes('Android')) {
                body += `### ü§ñ Android Tests\n`;
                body += `- Status: ${emoji} ${status}\n\n`;
              } else if (workflow.name.includes('iOS')) {
                body += `### üçé iOS Tests\n`;
                body += `- Status: ${emoji} ${status}\n\n`;
              } else if (workflow.name.includes('macOS')) {
                body += `### üñ•Ô∏è macOS Tests\n`;
                body += `- Status: ${emoji} ${status}\n\n`;
              } else if (workflow.name.includes('Linux')) {
                body += `### üêß Linux Tests\n`;
                body += `- Status: ${emoji} ${status}\n\n`;
              }
            }
            
            body += `---\n`;
            body += `üîó [View Full Logs](${workflow.html_url}) | `;
            body += `üìù Run #${workflow.run_number} | `;
            body += `‚è±Ô∏è ${new Date().toLocaleString('en-US', { timeZone: 'UTC', hour12: false })}\n`;
            
            // Find existing comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
            });
            
            const botComment = comments.data.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Crashpad Test Results')
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: body
              });
            }